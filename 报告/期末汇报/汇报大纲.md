## 汇报大纲
### P3 首先介绍一下我们的项目背景，包括技术依据、项目简介和可应用场景。

P4 首先是技术依据，

一方面是物联网技术的发展使远程控制需求增加，另一方面是智能家居中杂乱的控制方式不够方便，基于浏览器技术可以直接在浏览器中访问控制界面，更加统一方便。

第二个是树莓派，它是一种单板计算机，性能好，功耗不高，并且接口丰富、易于扩展。

第三个是WASM，它是一种二进制指令格式，是我们项目的重点，首先这种格式的代码运行快、可以处理复杂的计算任务而不会显著降低Web应用的性能，其次它跨平台兼容性好，能够更好地覆盖用户群体。

第四个是语音识别技术，它作为最自然的人机接口，已经发展到具有高识别准确率、能够实时反馈、具有良好的自然语言处理能力，为我们的项目奠定基础。

P5 于是将以上这些要素结合起来，我们的项目应运而生，我们要做的是基于WASM的树莓派语音控制模块，浏览器实现远程控制，WASM加速前端计算，树莓派执行指令。

P6 接着介绍可应用场景，

首先是智能家居，市面上不同品牌的设备的控制方式各异，使得控制繁琐，而我们的项目能够实现统一接口跨设备联动。
然后是适老化，随着老龄化加剧，老年人的生活需要被关注，他们通常难以学会控制复杂的智能设备，而我们的项目可以实时语音反馈，并且未来可以实现方言适配和一些定制服务，便于老年人使用。

### P7 然后介绍我们项目的整体架构。

P8 首先如图是我们的完整工具链，从用户对着网页说出“开灯”，到浏览器将音频识别为标准文本，再到WSAM将标准文本指令转化为树莓派控制执行，通过HTTP发送给树莓派，树莓派控制GPIO引脚做出操作，实现LED灯光的点亮。

P9 分层处理

我们将整个项目分为了三层：

用户（浏览器）：这是用户与系统交互的前端界面。

Web服务器（计算机）：这是处理用户请求的中间层，负责与用户和指令之间的服务器通信。

树莓派（指令服务器）：这是执行具体操作的后端设备，比如控制GPIO（通用输入输出）。

这么分层有三个优势：

首先是安全性高：

通过分层处理，敏感操作（如GPIO控制）被隔离在后端设备上，前端用户无法直接访问这些操作，从而提高了系统的安全性。

扩展性强：

各个层次之间通过标准化的接口进行通信，使得系统更容易扩展。例如，可以轻松替换或升级某个层次的组件，而不会影响到其他层次。

其次是便于优化：

分层处理使得每个层次可以独立优化。例如，可以针对Web服务器进行性能优化，而不影响树莓派的控制逻辑。

P10 落实到技术上，有三层架构，

首先是浏览器端，我们需要实现开发一个HTML网页以实现语音识别、然后用C编写指令解析逻辑并编译为WASM完成指令解析、然后是指令传输，将指令发送给树莓派端服务器。

然后是树莓派端，我们需要创建一个简单的服务器用来接收指令，并通过RPI.GPIO库控制引脚。

最后是硬件端，将LED连接到树莓派的引脚上，根据指令实现控制。

### 接下来我们细讲浏览器端的语音识别及合成

我们主要使用的是Web Speech API，它是一个浏览器内置的语音识别接口，无需额外插件。它将麦克风采集的音频流出来自动编码并发送给云端识别服务，主要优点是浏览器原生支持，无需下载其他额外插件；且实时处理能力强。
为了实现特定词语唤醒，我们使用了双模式语音识别引擎，来实现唤醒词和指令识别的同时实现，同时使用双缓冲机制实现两个模式的独立运行。
最后为了实现更好的用户交互，我们使用的是Speech Synthesis接口实现了语音合成，不同状态会有不同的语音反馈，比如执行成功后会回应“灯已打开”。但现存问题为，在移动端的edge浏览器收到webkit结构的限制，不支持该功能，因此我们降级为文字提示。
### 下面是我们的项目重点指令解析部分：

1.	WASM优势：
首先是WASM 能加速指令解析。那为什么可以加速指令解析呢？从原理上讲：
它是二进制格式的字节码，加载后无需像 JS 那样经历词法分析、语法解析和 JIT 编译。测试数据显示，在指令映射场景中，WASM 比 JS 快 3-10 倍（展示性能对比图）
其次是WASM具有高度的跨平台特性，无需额外适配即可在 90% 以上的用户终端运行，极大降低开发成本与维护复杂度

2.	部署
我们在中期汇报的时候有提到过，WASM可以部署在浏览器端也可以部署在树莓派端，但是经过讨论，我们最终选择了将WASM部署在浏览器端。
因为，第一，智能家居常用的家庭或办公 Wi-Fi 环境中，用户体验对响应速度极为敏感。在远程控制流程里，指令解析环节是最主要的耗时瓶颈。因此我们优先考虑加速前端计算，而非过度关注硬件控制的安全性问题
第二是，树莓派作为边缘设备，计算资源存在天然限制。若采用 “原始文本传输 + 树莓派 WASM 解析" 的方案，树莓派需要同时承担 WASM 运行时加载、指令解析及硬件控制等多重任务，这会导致严重的实时性损耗。而浏览器端部署方案中，树莓派仅需执行轻量级的 GPIO 控制指令，大幅降低了资源占用压力

3.	混合指令解析架构
讲完了WASM的优势和部署位置后，现在来讲一下我们系统的整体架构。
我们采用了混合指令解析架构，将传统的“AI + Javascript“改为“AI+WASM本地加速“。
也就是当我们发出请求，“麻烦帮我把客厅的照明设备打开”或者其他国家的语言"Turn on the light" 大模型会分析并生成标准指令“开灯”，然后WASM加速标准化指令到 GPIO 命令的映射
这里的技术分工非常清晰：大模型负责 "理解意图"，WASM 负责 "快速执行"，形成 "云端智能 + 本地加速" 的高效组合。


下面我们具体讲述一下混合指令解析架构的实现流程

4.	大模型api部署
首先是配置阶段。系统支持多种大模型服务商， OpenAI、智谱 AI 等，也可自定义 API
然后，用户需要在网页端填入相应的 API 密钥和选择合适的模型。网页内部会根据用户选择的服务商设置模型
此外，我们还设置了对API连接的测试功能，确保大模型配置正确
这个是以伪代码形式写出来我们的代码中请求大模型处理的模块（ppt step3上的图片）
5.	大模型生成标准指令
这里的核心逻辑是，当用户说出语音指令后，我们得让大模型把这些 “日常说话” 转化成系统能看懂的标准化指令
怎么实现的呢？我们会构建一个提示词（ppt图片），就像这样，把用户说的话，比如 “把客厅灯打开”，放进提示词里，告诉大模型：“你得分析这是不是智能家居控制指令，要是的话，按照我们规定的设备和操作，转成简单指令” 
比如说设备这块，不管用户说 “灯”“照明设备” 还是 “灯光”，大模型得统一识别成 “灯”；操作也是，“打开”“开启” 这些，统一变成 “开” 。这样做的好处是，后面不管是 WASM 处理，还是控制硬件，都能基于统一的标准来，不会乱套。
然后大模型会返回 JSON 格式的结果，里面有标准化指令、置信度这些。要是识别不出来，也会返回对应的提示，让系统知道怎么回应用户。
6.	WASM编译流程
C++ 实现解析逻辑，通过匹配关键词生成 GPIO 命令；
使用 Emscripten 编译，生成响应的.js和.wasm
最后浏览器端加载WASM模块并运行

### 下一部分是指令传输与树莓派执行部分

首先是总体服务架构图，浏览器端将JSON格式的指令通过HTTP协议传给Flask服务器，然后通过GPIO控制器控制相关物理设备。关于物理设备，树莓派的GPIO示意图如右图所示

然后是我们的指令传输部分的通信方案设计，其设计的关键是针对本项目这种小型、资源有限的树莓派控制应用进行选择


首先要选择通信协议，我们了解了一些通信协议，如http和ftp，并最终选择了http，因为它（ppt内容：前端浏览器天然支持，无需额外客户端库；传输延迟低，适合本项目的要求，与flask等轻量级框架集成简单高效，）
至于我们如何解决实时性，（ppt内容：我们采用轮询获取设备状态，指令完成后，服务器主动返回状态更新，对于关键指令，增加执行确认机制）

然后我们要选择数据传输格式，经过调研后选择json格式，因为它（ppt内容：轻量级，适合网络传输，对于树莓派这种资源有限的设备，轻量级数据格式可以提高系统响应速度，并且几乎所有现代编程语言都支持json格式）

下一部分就是树莓派执行，我们需要在树莓派段运行一个服务器，实时接收网页端传来的指令信息。我们要选择服务器框架，经过调研，我们选择flask框架，因为它（ppt内容：易于部署，适用于树莓派这种资源简单的设备，它适用于小型项目，针对本项目，flask能够提供足够的性能和功能支持，灵活性高，可以集成gpio库来控制引脚，社区支持和文档丰富，便于学习）

最后是我们flask服务器的执行过程，第一步从客户端接收json格式的控制指令，包含gpio命令，第二步检查指令是否包含必要的字段，检验是否合法，第三步根据指令控制树莓派的gpio引脚，实现设备开关操作，第四步向客户端返回操作结果，包含成功或失败信息、设备状态等。

同时，我们开启了日志记录，记录请求和操作结果，便于调试和监控；
还设置了开机自启，只要下载文件并开启自启功能，即可通过对应网址实现家电控制。

### 下面就是我们的现场演示环节。
### 接下来是评估与可靠性分析

我将会从测试方法与架构、测试结果、wasm优势和可靠性四个方面分析

首先：我们使用Windows10操作系统和Node.js模拟树莓派的环境，使用了WASM+JavaScript和Node.js的技术，以总响应时间为指标，测试了从语音输入、语音识别、指令解析再到设备响应的完整过程

接下来是Node.js的测试优势：

Node.js在这个项目中实际上承担了"轻量级测试框架"的角色，提供了一个接近真实部署环境（树莓派Linux）但又具备完整开发工具链的测试平台，它的V8引擎原生支持 WebAssembly 字节码执行，还具有高精度计时和精准控制变量的优势

以下是测试结果，我们的测试文件均在github上有存留，每次测试结果略有不同但总体结果相似

我们为什么要使用wasm？这里要再次强调一下其重要性和优势：

wasm是由代码编译为字节码，而字节码能使执行效率高于JavaScript，其他优势还有计算密集、类型安全等

最后是关于测试结果可靠性的说明，因为我们会进行多次完整的测试，而每一次测试都会有wasm和JavaScript的对比；我们测试的时间精度控制在ns级，保证准确性；在每次测试前，连续执行会导致WASM和JS代码在CPU缓存中相互覆盖，使用setTimeout 1秒间隔让CPU缓存"冷却"，确保每次测试都是相同的起始状态，给垃圾回收器时间清理内存，让系统负载回到稳定状态，另外，每次测试的数据结果都会被保存在voice-control-test-results.json文件中，有迹可循

### 接下来介绍我们项目的拓展及未来工作

首先是多语言支持

计划实现多语言和多方言的识别及反馈，让广大老人能够使用此设备，完善适老化需求，同时让用户可以选择不同的声音，而非单一的声音反馈，改善用户体验

然后是离线识别和本地模型的部署，

将开发不依赖云服务的离线识别功能，让更多浏览器可以使用本项目，同时优化本地模型性能，减少资源占用
（在此前，我们已尝试在树莓派本地部署vosk语音识别模型，但是总以树莓派资源不足而失败）

然后是加强访问的安全性，

目前有三个方向加强访问的安全性，分别是
加强身份认证给和访问控制，
在传输过程中进行数据加密，
进行VPN或反向代理，仅允许安全通道访问

最后是未来优化资源调度管理

在未来控制多个设备时进行资源优化管理，
集成可视化监控工具，监控各设备的电量资源使用情况，合理调控资源使用，实现智能家居

### 最后，让我们对这个项目做一个总结。我们从我们的核心优势、项目价值、当前挑战、未来展望四个方面总结，
首先是核心优势。

- 我们采用了浏览器作为终端，这为用户提供了极大的便利。用户只需通过浏览器输入语音指令，而不需要下载任何软件。这一步简化了设备管理。

- 下一个优势是WASM 性能。从 WebAPI 处理后的指令会传递给WASM 模块进行深度解析。WASM 凭借其接近原生代码的执行效率，在网页端高效运行，确保指令解析的实时性与准确性。提升了性能。

然后是项目价值。

在未来，它可以应用于智能家居、农业监测和机器人控制等多种场景。当前，我们利用 WebAPI 实现浏览器端的语音交互，结合 WASM 模块进行高效指令解析，并通过树莓派执行任务。希望未来扩展到教育、工业监测等更多领域。

至于当前问题。

目前，我们使用 HTTP 协议通过 8080 端口提供服务，这在数据传输安全性上存在明显缺陷，容易导致数据泄露或未授权访问。
此外，我们依赖 WebAPI 进行语音识别，其网络依赖性限制了离线场景的应用，影响了隐私保护和稳定性的提升。限制了此项目的提升。


最后，在未来

为了应对这些挑战，我们计划采取以下措施。

- 首先，启用 HTTPS，确保所有数据传输都经过加密，提升安全性。
- 同时，我们将引入 Vosk 语音识别框架，替代 WebAPI，实现本地化语音处理，增强离线能力和隐私保护。
- 此外，我们将优化WASM 模块部署，实现模块隔离，并完善资源调度策略，确保系统的高效运行与稳定性。

（我们的介绍到此结束，感谢大家倾听，欢迎大家的提问。）



